<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Back Home AR â€” AR.js Pinned (WebXR-like stability)</title>
  <script src="https://cdn.jsdelivr.net/gh/aframevr/aframe@1.6.0/dist/aframe-master.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:transparent; }
    #soundOverlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,0.6); color:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; z-index:9999; }
    #soundOverlay button{ background:#1976d2; color:#fff; border:0; border-radius:10px; padding:12px 18px; font-weight:700; }
  </style>

  <script>
    // --- Helper: quaternion average via eigenvector of scatter matrix ---
    function averageQuaternion(quats){
      const M = new Array(16).fill(0);
      for(const q of quats){
        const v=[q.x,q.y,q.z,q.w];
        // outer product vv^T into 4x4 M
        let idx=0;
        for(let r=0;r<4;r++){
          for(let c=0;c<4;c++){
            M[idx++] += v[r]*v[c];
          }
        }
      }
      // Power iteration to get dominant eigenvector (simple & stable here)
      let ev = [0,0,0,1]; // start near w-axis
      for(let it=0; it<16; it++){
        const nv=[0,0,0,0];
        // nv = M * ev
        for(let r=0;r<4;r++){
          nv[r] = M[r*4+0]*ev[0]+M[r*4+1]*ev[1]+M[r*4+2]*ev[2]+M[r*4+3]*ev[3];
        }
        // normalize
        const len = Math.hypot(nv[0],nv[1],nv[2],nv[3]) || 1;
        ev = [nv[0]/len, nv[1]/len, nv[2]/len, nv[3]/len];
      }
      const q=new THREE.Quaternion(ev[0],ev[1],ev[2],ev[3]);
      q.normalize();
      return q;
    }
  
    // --- Robust median ---
    function medianVec3(vecs){
      const xs=vecs.map(v=>v.x).sort((a,b)=>a-b);
      const ys=vecs.map(v=>v.y).sort((a,b)=>a-b);
      const zs=vecs.map(v=>v.z).sort((a,b)=>a-b);
      const mid = Math.floor(xs.length/2);
      const pick = (arr)=> arr.length%2? arr[mid] : 0.5*(arr[mid-1]+arr[mid]);
      return new THREE.Vector3(pick(xs), pick(ys), pick(zs));
    }
  

    AFRAME.registerComponent('pin-once-pro', {
      schema:{
        target:{type:'selector'},
        streak:{type:'int', default: 28},          // consecutive stable frames required
        posEps:{type:'number', default: 0.0005},   // meters/frame
        rotEpsDeg:{type:'number', default: 0.15},  // degrees/frame
        manual:{type:'boolean', default:false}     // tap to pin (after stable)
      },
      init:function(){
        this._collect=false; this._done=false;
        this._lastPos=new THREE.Vector3();
        this._lastQuat=new THREE.Quaternion();
        this._tmpPos=new THREE.Vector3();
        this._tmpQuat=new THREE.Quaternion();
        this._tmpScale=new THREE.Vector3();
        this._stable = [];           // holds recent stable poses
        this._stableMax = this.data.streak;
  
        this._onClick = this._onClick.bind(this);
  
        this.el.addEventListener('markerFound', ()=>{
          if(this._done) return;
          this._collect = true;
          this._stable.length = 0;
        });
  
        this.el.addEventListener('markerLost', ()=>{
          if(this._done) return;
          this._collect = false;
          this._stable.length = 0;
        });
  
        if (this.data.manual) {
          window.addEventListener('click', this._onClick);
        }
      },
      remove:function(){
        window.removeEventListener('click', this._onClick);
      },
      _onClick:function(){
        if (!this.data.manual || this._done || !this._collect) return;
        if (this._stable.length >= this._stableMax) {
          this._finalizePin();
        }
      },
      tick:function(){
        if(this._done || !this._collect) return;
  
        const obj=this.el.object3D;
        obj.updateMatrixWorld(true);
        obj.matrixWorld.decompose(this._tmpPos, this._tmpQuat, this._tmpScale);
  
        if(this._stable.length===0){
          this._lastPos.copy(this._tmpPos);
          this._lastQuat.copy(this._tmpQuat);
        }
  
        const move = this._tmpPos.distanceTo(this._lastPos);
        const dot  = Math.abs(THREE.MathUtils.clamp(this._lastQuat.dot(this._tmpQuat), -1, 1));
        const ang  = THREE.MathUtils.radToDeg(2*Math.acos(dot));
  
        // Only accept if motion is tiny; otherwise reset the streak.
        if (move <= this.data.posEps && ang <= this.data.rotEpsDeg) {
          this._stable.push({ pos: this._tmpPos.clone(), quat: this._tmpQuat.clone() });
          if (this._stable.length > this._stableMax) this._stable.shift();
        } else {
          this._stable.length = 0;
        }
  
        this._lastPos.copy(this._tmpPos);
        this._lastQuat.copy(this._tmpQuat);
  
        if (!this.data.manual && this._stable.length >= this._stableMax) {
          this._finalizePin();
        }
      },
      _finalizePin:function(){
        // Robust aggregate
        const positions = this._stable.map(s=>s.pos);
        const quats     = this._stable.map(s=>s.quat);
        const avgPos    = medianVec3(positions);
        const avgQuat   = averageQuaternion(quats);
  
        const t = this.data.target && this.data.target.object3D;
        if (!t) { this._done=true; return; }
  
        // Detach to scene (world space), then freeze transform
        this.el.sceneEl.object3D.attach(t);
        t.matrixAutoUpdate = false;
        t.frustumCulled = false;            // avoid renderer culling wobbles
        const S = new THREE.Vector3(1,1,1);
        const M = new THREE.Matrix4().compose(avgPos, avgQuat, S);
        t.matrix.copy(M);
        t.updateMatrixWorld(true);
  
        // Hide the anchor so it can't alter anything later
        this.el.setAttribute('visible', false);
  
        this._done = true;
        this._collect = false;
        this._stable.length = 0;
      }
    });
  </script>  
</head>

<body>
  <!-- One-tap audio unlock (required by mobile browsers) -->
  <div id="soundOverlay"><div style="text-align:center">
    <div style="margin-bottom:10px;font-size:18px">Tap to enable sound ðŸ”Š</div>
    <button id="soundBtn">Enable Audio</button>
  </div></div>

  <a-scene
    vr-mode-ui="enabled:false"
    embedded
    renderer="antialias:true; alpha:true; precision:medium"
    arjs="sourceType: webcam; trackingMethod: best; debugUIEnabled:false"
  >
    <a-assets>
      <video id="videoColor"
             src="https://raw.githack.com/alevalve/AR_Crab_Backhome/main/AR_Video02_Color.mp4"
             loop muted playsinline webkit-playsinline crossorigin="anonymous"></video>
      <video id="videoAlpha"
             src="https://raw.githack.com/alevalve/AR_Crab_Backhome/main/AR_Video02_Alpha.mp4"
             loop muted playsinline webkit-playsinline crossorigin="anonymous"></video>
    </a-assets>

    <!-- NFT marker: heavy smoothing only for the brief "collect" phase -->
    <a-nft
      type="nft"
      url="https://raw.githack.com/alevalve/AR_Crab_Backhome/main/marker/AR_Image-tracker_Crab"
      smooth="true" smoothCount="60" smoothTolerance="0.005" smoothThreshold="5"
      pin-once-pro="target:#pinned; streak:32; posEps:0.0005; rotEpsDeg:0.15; manual:false"
    >
      <a-entity id="pinned"
        geometry="primitive: plane; width: 0.85; height: 0.67"
        material="shader: video-matte; videoColor: #videoColor; videoAlpha: #videoAlpha; transparent:true; depthWrite:false"
        position="0 0 0.001" rotation="-90 0 0">
      </a-entity>
    </a-nft>


    <!-- AR.js controls camera; keep look-controls off to avoid device sway -->
    <a-entity camera look-controls="enabled:false"></a-entity>
  </a-scene>

  <script>
    const overlay = document.getElementById('soundOverlay');
    const btn = document.getElementById('soundBtn');
    const vc = document.getElementById('videoColor');
    const va = document.getElementById('videoAlpha');

    // Start muted so autoplay works; visuals appear even before audio
    Promise.allSettled([vc.play(), va.play()]);

    // User gesture to enable sound (mobile policy requirement)
    btn.addEventListener('click', () => {
      vc.muted = false;
      vc.currentTime = 0; va.currentTime = 0;
      vc.play(); va.play();
      overlay.style.display = 'none';
    });
  </script>
</body>
</html>
